# EAD7 — 次世代引継ぎドキュメント（要点まとめ）

## 1) 高レベル仕様（速攻リファレンス）

* 暗号本体: **AES-256-GCM**（EAD7 v1 に割り当て）

  * Nonce: **96 bit (12B)** ランダム毎回生成
  * Tag: **128 bit (16B)**
  * AAD: ヘッダ全体（magic/ver/alg/mkid/kid/nonce）を必ず渡す
* 出力形式:

  * 文字列用途 → **Base64**（URL-safeは任意）
  * ファイル用途 → **バイナリそのまま**
* ヘッダ（バイナリ順序）:

```
[ magic:2B (0xE7 0x01) ]
[ ver:1B ]
[ alg:1B (0x01 = AES-256-GCM) ]
[ mkid:1B ]           // 主に1 -> 0x01
[ kid:16B ]           // ルーム/相手識別子（16Bランダム、Base64=24chars）
[ nonce:12B ]         // AES-GCM nonce
[ciphertext:var]
[tag:16B]
```

## 2) 鍵階層（必ず押さえること）

* **MK (Master Key)** — 32B（256bit）ランダム。開発者のみ保持。最上位のRoot of Trust。
* **KEK (Key Encryption Key)** — 相手/ルームごとに固定。

  * 生成: `KEK = HKDF-SHA256( IKM=MK, salt=*, info="EAD7|KEK|<KID>" , L=32 )`
* **DEK (Data Encryption Key)** — 暗号文ごとに変わる一時鍵。

  * 生成: `DEK = HKDF-SHA256( IKM=KEK, salt=*, info="EAD7|DEK|<Nonce>" , L=32 )`
* **HMAC用キー**（ファイル署名用） — KEK（専用）から `HKDF(... info="EAD7|KIDLIST-HMAC")` などで派生するの推奨。

> salt は現状省略（0）でOKだが、将来的には保存saltを使う設計を許容すること（ファイルごとのsaltも可能）。

## 3) KID（ルームID）運用

* **KID = 16B ランダム**（Base64 表記で24文字固定）
* KIDは暗号文に埋め込む（平文）して問題なし（KID公開＝復号不能への影響なし）
* KID は相手ごとに固定（ルーム単位）で使う運用。Nonceで暗号ごとの一意性を確保する。

## 4) KDF と info の定義（厳守）

* KEK info: `"EAD7|KEK|<KID>"`
* DEK info: `"EAD7|DEK|<Nonce>"`
* HMACキー info: `"EAD7|KIDLIST-HMAC"` または `"EAD7|HMAC|<sys-kid>"`
* HKDF: **HKDF-SHA256** を標準で採用（KEK/DEK は 32B 出力）

## 5) MK の生成・保存（方針3：ランダムMKをパスでラップ）

* MK 生成: **CSPRNG 32B**（AutoSeededRandomPool / libsodium randombytes\_buf）
* MKは**平文で保存しない**。保存はラップ（暗号化）して行う。
* ラップ方式（現状推奨、実装済み例）: **libsodium + Argon2id + XChaCha20-Poly1305 (AEAD)**

  * KDF: `crypto_pwhash(..., alg=ARGON2ID13, opslimit=MODERATE, memlimit=MODERATE)`
  * Wrap AEAD: `crypto_aead_xchacha20poly1305_ietf_encrypt`（nonce 24B）
* 保存JSON例 (`mk_wrap.json`):

```json
{
  "version":1,
  "kdf":{
    "alg":"Argon2id", "opslimit":"MODERATE","memlimit":"MODERATE","salt":"<Base64 16B>"
  },
  "wrap":{
    "nonce":"<Base64 24B>",
    "ct":"<Base64 ciphertext (mk_len + tag)>"
  },
  "mkid":"01"
}
```

* 復元フロー: パスワード入力 → `crypto_pwhash` → wrapKey → AEAD decrypt → MK 復元

## 6) KID一覧ファイル仕様（最終採用フォーマット）

* 1行目: **HMAC-SHA256 を Base64 表記**（ファイル全体 body に対する HMAC）

  * 固定長（Base64 of 32B = 44 chars with padding, or URL-safe no-padding variant shorter）
* 2行目以降: **KID(24chars Base64 fixed)** の直後にスペース1つ、残りをルーム名（任意の文字列、スペースOK）

  * パースルール: 先頭24chars = KID、25文字目以降を room name
* 例:

```
<44-char HMAC base64>
QUFCQ0RFRjEyMzQ1M0FCQw== RoomA
MTIzNDU2Nzg5QUJDREVGRw== Room With Space
OUY4RTdENkM1QjRBNjU0Mz== AnotherRoom
```

* HMACキー: **専用KEK（sys-KIDで識別）から HKDF 派生**して得る (`info="EAD7|KIDLIST-HMAC"`)

## 7) HMAC 実装＆処理手順（読み込み時）

* 読込:

  1. ファイル開いて1行目を `hmac_stored` として読み取る
  2. 残り（body）をそのまま文字列（改行含む）として `body` に取得
  3. `hmac_calc = HMAC-SHA256( key = HMACKey, data = body )` を計算し Base64 表記と比較
  4. 不一致 → 改ざん検出。停止。
  5. 一致 → パース（各行の先頭24charsとルーム名取り出し）
* HMACKey の生成: `HMACKey = HKDF( IKM = KEK_sys, info="EAD7|KIDLIST-HMAC", L=32 )`
* 注意: ボディの改行扱い（保存時と検証時で完全一致させること）

## 8) 暗号化 / 復号 フロー（クライアント）

* 暗号化（送信側）:

  1. 受信者の KID を取得 → KEK = HKDF(MK, info="EAD7|KEK|KID")
  2. nonce = random 12B
  3. DEK = HKDF(KEK, info="EAD7|DEK|nonce")
  4. ciphertext, tag = AES-256-GCM( key=DEK, nonce=nonce, aad=header )
  5. 出力 = header || ciphertext || tag → Base64 if text mode
* 復号（受信側）:

  1. header から KID と nonce を取り出す
  2. KEK（ローカルにない場合は配布/取得手順）を参照
  3. DEK = HKDF(KEK, info="EAD7|DEK|nonce")
  4. AES-GCM decrypt with AAD header and verify tag

## 9) KEK配布方針（現実運用）

* KEK は開発者（MK所有者）が生成して配布する（TLSや公開鍵ラップを利用）
* 配布方法候補:

  * 受信者の公開鍵で KEK をラップ（RSA-OAEP / ECIES） → 安全
  * TLS 経由で一時的に渡す（受信側で OS ストアに格納 or ユーザパスでラップ）
* 受信側保存: **OS 秘密ストアが使えるならそれを優先**。使えない場合は受信者のユーザパスで wrap してファイル保存。

## 10) ライブラリとビルドメモ（実装で使った/推奨）

* **libsodium**: MKラップ（Argon2id + XChaCha20-Poly1305） → 推奨。MSYS2 パッケージ `mingw-w64-x86_64-libsodium` がある。
* **Crypto++**: HKDF/HMAC/AES-GCM（もし AES-GCM 本体を Crypto++ で実装するなら）。MSYS2 パッケージ `mingw-w64-x86_64-cryptopp`。
* ビルド (CMake + Ninja) の例:

```cmake
target_link_libraries(${PROJECT_NAME} PRIVATE cryptopp sodium)
```

* 注意: 混用可だが鍵バイト配列の取り扱い（SecByteBlock vs std::vector<unsigned char>）を整えること。

## 11) 具体値・推奨パラメータ（そのまま使える）

* MK length: **32B**
* KID length: **16B (Base64=24chars)**
* Nonce (AES-GCM): **12B**
* Tag (AES-GCM): **16B**
* HKDF: SHA256, L=32B
* Argon2id (libsodium): `crypto_pwhash_OPSLIMIT_MODERATE`, `crypto_pwhash_MEMLIMIT_MODERATE`（個人利用向け）
* HMAC: HMAC-SHA256, key=HKDF(..., info="EAD7|KIDLIST-HMAC")

## 12) ファイル/データの命名・場所（運用例）

* MKラップファイル: `mk_wrap.json`（安全にバックアップ。パーミッション600）
* KID一覧: `kid_list.txt`（1行目 = HMAC, 2行目以降: KID(24charBase64) + ' ' + RoomName）
* KEKストア（暗号化保存）: `kek_store.json`（各エントリに kid, nonce, ct, tag）
* 暗号文拡張: `*.ead7` 拡張子推奨

## 13) 運用手順（緊急時含む）

* 初回: MK生成 → mk\_wrap.json にラップして保存（USBにオフラインバックアップ）
* KEK発行: MKより `KEK = HKDF(MK, info="EAD7|KEK|KID")` を生成 → KEKを受信者に配布（公開鍵ラップ）
* KID一覧更新: 管理ツールで編集 → body を保存 → HMAC = HMAC(HMACKey, body) を1行目に記入
* ローテーション（MK疑念時）: 新MK生成 → KEK再作成 → KEKストア再ラップ → 古MKファイル安全廃棄
* 定期バックアップは必須（少なくとも2箇所）

## 14) 実装チェックリスト（開発者向け）

* [ ] libsodium と Crypto++ のインストール確認（MSYS2）
* [ ] mk\_wrap 読込/書込実装（Wrap/Unwrapの対）
* [ ] HKDF( MK + KID → KEK ) のラッパー実装（Crypto++ または libsodium HKDF 実装）
* [ ] DEK導出 (KEK + Nonce → DEK) 実装
* [ ] AES-256-GCM encrypt/decrypt ラッパー（AAD = header）
* [ ] kid\_list の HMAC 署名/検証実装（HMACKey 派生）
* [ ] Base64/Hex デバッグヘルパ関数（Hexは大文字）
* [ ] ファイルパーミッションとバックアップ処理追加
* [ ] 単体テスト: 固定MK/KID/Nonce で暗号→復号ベクトルを作成してCIで監査

## 15) よくある落とし穴（要確認）

* Nonce の再利用は絶対にしない（AES-GCM致命）。Nonce生成方法はCSPRNGで毎回新規。
* AAD の並び順を仕様で固定。順序が変わると認証失敗する。
* HMAC の検証対象（ボディ）にファイル末尾の改行含めるなど、保存と検証で完全一致させる。
* 密かな依存（例: Base64 variant ）（保存と検証で同一 variant を使うこと）
* MK を複製して複数箇所に置く場合、バックアップの暗号化管理も忘れずに。

---

## 16) 参考コードの場所（このチャットで出したもの）

* libsodium wrap/unwrap サンプル（Argon2id + XChaCha20-Poly1305）：動作確認済み
* Crypto++ HKDF+AES-GCM サンプル（概念実装）: HKDF関数、HexEncode、DEK生成の雛形あり
* HMAC calc + kid\_list parser サンプル：関数スニペットあり

（必要ならここから簡単にファイル群として吐き出す／GitHub README 風に整形するよ）

---

## 17) 次へやるべき優先タスク（実務順）

1. mk\_wrap.json の読み書き実装（wrap/unwrap動作のCIテスト）
2. HKDF(MK,KID)->KEK ラッパー実装 + 単体テスト
3. KEKを libsodium でラップして `kek_store.json`（各 KEK を wrap ）の実装
4. AES-256-GCM ラッパー実装（暗号/復号、AAD固定）
5. KID一覧（kid\_list.txt）読み書き + HMAC 検証の実装
6. 総合テスト： MK生成→KEK配布ラップ→暗号化→復号 の end-to-end テスト
7. ドキュメントと運用手順書をリポジトリに置く
